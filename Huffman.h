#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <cstdlib> 
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;

// Building unit of the tree
struct Node
{
    char ch;
    int freq;
    Node* left, * right;
};

// Comparison object to order nodes
struct compare
{
    bool operator()(Node* l, Node* r)
    {
        
        return l->freq > r->freq; // The higher the priority, the less frequency.
    }
};

Node* getNode(char, int, Node*, Node*); // Creates a new tree node with the character and its frequency
void encode(Node*, string, unordered_map<char, string>&); // Goes throught the tree and stores the huffman code in a map
void decode(Node*, int&, string); // Decodes the Encoded string generated by the huffman code
void Huffman(vector<char>, string filename); // Builds Huffman Tree and decode given input text
void compress(string Data, string Fl); // Changes all characters into octets to make their size smaller and the file compressed
string decompress(string Fl); // Changes the octets charachter from the compressed file back to the 0's & 1's representation
int get_file_size(string filename); // Returns the size of the file with the given file name


Node* getNode(char ch, int freq, Node* left, Node* right)
{
    Node* node = new Node();

    node->ch = ch;
    node->freq = freq;
    node->left = left;
    node->right = right;

    return node;
}
void encode(Node* root, string str, unordered_map<char, string>& huffmanCode)
{
    if (root == nullptr)// If the tree is empty
        return;

    if (!root->left && !root->right) { // If the leaf node is found
        huffmanCode[root->ch] = str;
    }

    // Iterates until the leaf node is found
    encode(root->left, str + "0", huffmanCode);
    encode(root->right, str + "1", huffmanCode);
}
void decode(Node* root, int& index, string str)
{
    if (root == nullptr) {
        return;
    }

    if (!root->left && !root->right) // If the leaf node is found
    {
        //cout << root->ch;  // To print out the decoded string
        return;
    }

    index++;

    // Traversing down the tree
    if (str[index] == '0') 
        decode(root->left, index, str);
    else
        decode(root->right, index, str);
}
void Huffman(vector<char> Data, string filename)
{
  
    unordered_map<char, int> f; // map each character with the frequency of occurrence
    for (char c : Data) {
        f[c]++;
    }

    /*cout << "Original text is:\n";
    for (char c : Data)
        cout << c;*/

    
    // printing out the frequency 
    cout << "\nFrequency of each character is:\n";
    for (auto x : f)
        cout << x.first << ": " << x.second << endl;



    // Priority queue storing the nodes of the tree
    priority_queue<Node*, vector<Node*>, compare> pq;

    // Create a leaf node for each character and add it to the priority queue.
    for (auto pair : f) {
        pq.push(getNode(pair.first, pair.second, nullptr, nullptr));
    }


    while (pq.size() != 1)
    {
        // Take out  the two nodes of highest priority (lowest frequency) from the queue
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top();	pq.pop();

        // Creating a new internal node with these two nodes
        // as children and with frequency equal to the sum
        // of the two nodes' frequencies. Add the new node
        // to the priority queue.
        int sum = left->freq + right->freq;
        pq.push(getNode('\0', sum, left, right));
    }

    // root stores pointer to root of Huffman Tree
    Node* root = pq.top();

    // traverse the Huffman Tree and store Huffman Codes
    // in a map. Also prints them
    unordered_map<char, string> huffmanCode;
    encode(root, "", huffmanCode);


    // Printing out the huffman codes
    cout << "\nHuffman Codes are :\n";
    for (auto pair : huffmanCode) {
        cout << pair.first << " " << pair.second << '\n';
    }

    // Creating encoded string
    string str = "";
    for (char ch : Data) {
        str += huffmanCode[ch];
    }
    // Printing out the encoded string
    cout << "\nEncoded string is :\n" << str << '\n';


    // Compressing the file into new file ending with Compressed.txt
    filename = filename + "Compressed.txt";
    compress(str, filename);


    

    // Decompressing back the compressed file in order to decode it 
    string str1= decompress(filename);


    // traverse the Huffman Tree again and this time
    // decode the encoded string
    int index = -1;
    while (index < (int)str1.size() - 2) {
        decode(root, index, str1);
    }
}
void compress(string Data, string Fl)
{
    ofstream inp;
    inp.open(Fl.c_str(), ios::trunc, ios::binary); //compressing the 1 and 0's from encoded file as they have greater size.
    int octets = Data.length() / 8;	//making new characters so that data is compressed and new file has less size.
    inp.write((char*)&octets, sizeof(int)); // writing the character to the new file

    int i = 0;
    while( i < (Data.length() / 8))
    {
        char c = '\0';
        for (int j = 0; j < 8; j++)
        {
            c = c << 1;
            if (Data[(i * 8) + j] == '0')
            {
                c = c | 0;
            }
            else
            {
                c = c | 1;
            }
        }
        inp.write((char*)&c, sizeof(char));
        i++;
    }

    if (Data.length() % 8 != 0)
    {
        string remData = Data.substr(octets * 8);
        for (int i = 0; i < remData.length(); ++i)
        {
            char oc = remData[i];
            inp.write((char*)&oc, sizeof(char));
        }
    }

    inp.close();
}
string decompress(string Fl)
{
    string Data = "";
    ifstream out;
    out.open(Fl.c_str(), ios::binary);
    int x;
    out.read((char*)&x, sizeof(int));
    for (int i = 0; i < x; ++i)	// geting the restored values in 0's & 1's from the compressed file 
    {
        char c;
        out.read((char*)&c, sizeof(char));
        for (int j = 0; j < 8; ++j)
        {
            char tmp = (char)128;
            if ((tmp & c) == tmp)
            {
                Data = Data + "1";
            }
            else
            {
                Data = Data + "0";
            }
            c = c << 1;
        }
    }
    char oc;
    while (out.read((char*)&oc, sizeof(char)))
    {
        Data = Data + oc;
    }

    return Data;
    out.close();
}
int get_file_size(string filename)
{
    ifstream in_file(filename, ios::in | ios::binary);
    in_file.seekg(0, ios::end);
    size_t file_size = in_file.tellg();
    return file_size;
}